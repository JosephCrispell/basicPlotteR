output <- list()
for(key in names(list)){
output[[key]] <- list[[key]] * value
}
return(output)
}
divideValuesInListByMax <- function(arrowRates){
max <- max(unlist(arrowRates), na.rm=TRUE)
output <- timesValuesInListByValue(arrowRates, 1/max)
return(output)
}
getArrowRates <- function(logTable){
# Initialise a list to store the arrow weights
arrowRates <- list()
# Get the column names
colNames <- colnames(logTable)
# Examine each column
for(col in colNames){
# Ignore all columns except the forward rate columns
if(grepl(x=col, pattern="forward") == FALSE){
next
}
# Skip rate if never estimate e.d. cattle-outer -> badger-inner
if(length(unique(logTable[, col])) <= 2){
next
}
# Get the directional information (i.e. 0_1, 2_0)
parts <- strsplit(col, split="_")[[1]]
direction <- paste(parts[length(parts) - 1], "_", parts[length(parts)], sep="")
# Store a summary statistic for the rate distribution
arrowRates[[direction]] <- logTable[, col]
}
return(arrowRates)
}
examineSubstitutionRateEstimates <- function(logTable, genomeSize){
# Get the substitution rate estimates note that stored differently between strict and relaxed
rateEstimates <- c()
if(length(which(grepl(colnames(logTable), pattern="mutationRate") == TRUE)) == 1){
rateEstimates <- logTable$mutationRate
}else{
rateEstimates <- logTable$ucedMean
}
# Define a colour palette based upon the likelihood
rbPal <- colorRampPalette(c('red','blue'))
colours <- rbPal(10)[as.numeric(cut(logTable$posterior,breaks = 10))]
colours <- sapply(head(colours), setAlpha, alpha=0.5, simplify=TRUE)
# Plot the substitution rate distribution versus the root height
plot(x=rateEstimates * genomeSize, y=logTable$tree.height, pch=20,
xlab="Substitution Rate (per Genome per Year)", ylab="Root Height (years)",
main="Substitution Rate versus Root Height",
col=colours, las=1, bty="n")
legend("topright", legend=c("High", "Low"), pch=20, col=c("red", "blue"),
bty="n")
}
plotPopulationSizes <- function(logTable, demeStructure, alpha=0.5){
# Get the population size distributions
popSizeEstimates <- list()
for(col in colnames(logTable)){
if(grepl(col, pattern="popSize") == FALSE){
next
}
popSizeEstimates[[strsplit(col, split="_")[[1]][2]]] <- logTable[, col]
}
# Get the deme names
demeNames <- getDemeNamesForDemeStructure(demeStructure)
# Define the limits of the population sizes and histogram breaks
values <- c()
for(key in names(popSizeEstimates)){
values <- c(values, popSizeEstimates[[key]])
}
xLim <- range(values)
breaks <- seq(from=xLim[1], to=xLim[2] + 5, by=5)
# Create a histogram object for each distribution of sizes
histograms <- list()
for(key in names(popSizeEstimates)){
histograms[[key]] <- hist(popSizeEstimates[[key]], plot=FALSE, breaks=breaks)
}
# Get the y axis limits
counts <- c()
for(key in names(histograms)){
counts <- c(counts, histograms[[key]]$counts)
}
yLim <- c(0, max(counts))
# Create a vector of colours
colours <- c("red", "blue", "green", "cyan", "orange", "darkorchid4", "deeppink", "black", "brown", "darkolivegreen")
# Plot the histograms
keys <- names(histograms)
for(i in 1:length(keys)){
if(i == 1){
plot(histograms[[keys[i]]],
col=setAlpha(colours[i], alpha), las=1,
main="Deme Effective Population Sizes", xlab="Effective Size",
ylim=yLim, xlim=xLim)
}else{
plot(histograms[[keys[i]]], col=setAlpha(colours[i], alpha), add=TRUE)
}
}
# Add legend
legend("topright", legend=demeNames, bty="n",
text.col=colours)
}
plotParameterESSValues <- function(logTable, colNamesToPlot){
essValues <- rep(NA, length(colNamesToPlot))
for(i in 1:length(colNamesToPlot)){
# Get the posterior values from the current column
values <- as.numeric(logTable[, colNamesToPlot[i]])
# Remove transition rate values when rate flag is set to zero
if(grepl(colNamesToPlot[i], pattern="migModel.rateMatrix") == TRUE){
# Get the deme numbers
parts = strsplit(colNamesToPlot[i], split="_")[[1]]
a <- parts[2]
b <- parts[3]
# Build the rate Flag column name
flagCol <- paste("migModel.rateMatrixFlag_", a, "_", b, sep="")
# Remove values where rate flag == 0
values <- values[logTable[, flagCol] != 0]
}
# Remove NAs, if present
values <- values[is.na(values) == FALSE]
# Note and skip those where the value is always the same
range <- range(values)
if(range[1] == range[2]){
#cat(paste("Parameter \"", colNamesToPlot[i],
#          "\" always has single value: ", range[1], "\n", sep=""))
next
}
if(length(essValues) > 1){
essValues[i] <- calculateEffectiveSampleSize(values)
}else{
essValues[i] <- length(essValues[i])
}
}
# Set the margins
par(mar=c(0,11,2,0.5)) # bottom, left, top, right
barplot(essValues, las=1, names=colNamesToPlot, horiz=TRUE, xaxt="n", cex.names=0.3,
main="Parameter Effective Sample Sizes")
abline(v=100, lty=2, col="red")
abline(v=1000, lty=2, col="blue")
text(x=c(250, 1200), y=c(0, 0), labels=c("100", "1000"), cex=0.5, col=c("red", "blue"))
# Reset Margins
par(mar=c(5.1, 4.1, 4.1, 2.1))
}
readInBASTALogTables <- function(date, demeStructures, popEstimationTypes,
clockEstimateTypes, path, nReplicates,
burnInProp=0.1, ignoreIfFlagged=FALSE){
# Store each of the log tables in a list
logTables <- list()
# Loop through the deme structures
for(demeStructure in names(demeStructures)){
# Loop through the population structures
for(popEstimationType in popEstimationTypes){
# Loop through the clock models
for(clockEstimationType in clockEstimateTypes){
# Initilialise a list to store the log tables for the current run's replicates
logTablesForReplicates <- list()
# Retrieve the data from each replicate
for(replicate in 1:nReplicates){
# Build run defining prefix
prefix <- paste(demeStructure, "_", popEstimationType, "_",
clockEstimationType, "_", replicate, "_", date, sep="")
# Print progress information
cat(paste("\rReading: ", prefix, ".log\tReplicate: ", replicate,
"\t\t\t\t\t", sep=""))
# Create file name
file <- paste(path, "Replicate", replicate, "_", date, "/",
prefix, "/", prefix, ".log", sep="")
# Read in the file as table
logTable <- read.table(file, header=TRUE, sep="\t", stringsAsFactors=FALSE)
# Replace "N" in table with NAs
logTable[logTable == "N"] <- NA
# Remove the burn-in
burnIn <- round(burnInProp * nrow(logTable), digits=0)
logTable <- logTable[burnIn:nrow(logTable), ]
# Calculate the forward rates
logTable <- calculateForwardMigrationRates(logTable)
# Store the logTable
logTables[[prefix]] <- logTable
}
}
}
}
cat("\rFinished reading in log tables...\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n")
return(logTables)
}
calculateForwardMigrationRates <- function(logTable){
# Get the names of the backward in time migration rate estimates
migrationRateCols <- colnames(logTable)[
grepl(colnames(logTable), pattern = "migModel.rateMatrix_")]
# For each backward in time migration rate calculate the forward migration rate
# FMR_ab = BMR_ba * (Nb / Na)
#   MR: Migration rate (F - Forward, B - Backward)
#   N: Effective population size
#   Demes: a, b
# Equation taken from second paragraph of Methods section in:
# De Maio et al. 2015 - New routes to phylogeography ...
#   BMR_ba = FMR_ab * (Na / Nb)
#   ->  FMR_ab = BMR_ba / (Na / Nb)
#     ->  FMR_ab = BMR_ba * (Nb / Na)
#
### NOTE: Backward rates are multiplied by rate flag before being used ###
# - Converts estimates to 0 when flag = 0 (i.e. rate turned off). If rate isn't likely, then they'll be a lot of zeros that will drag down estimate
# - Set to NA when flag = 0
for(backwardMigrationRateCol in migrationRateCols){
# Get the demes involved
parts <- strsplit(backwardMigrationRateCol, split="_")[[1]]
a <- parts[2]
b <- parts[3]
#### Multiply the backward rates by the rate flag column ####
backwardRate <- logTable[, backwardMigrationRateCol] * logTable[, paste("migModel.rateMatrixFlag_", a, "_", b, sep="")]
# Get the estimate population sizes for a and b
popASizes <- logTable[, paste("migModel.popSize_", a, sep="")]
popBSizes <- logTable[, paste("migModel.popSize_", b, sep="")]
# Calculate forward rate
forwardMigrationRateCol <- paste("migModel.forwardRateMatrix_", b, "_", a, sep="")
logTable[, forwardMigrationRateCol] <- backwardRate * (popASizes/popBSizes)
# Convert the rates to NAs when flag set to zero
logTable[, forwardMigrationRateCol][logTable[, paste("migModel.rateMatrixFlag_", a, "_", b, sep="")] == 0] <- NA
}
return(logTable)
}
getNSitesInFASTA <- function(fastaFile){
# Open a connection to a file to read (open="r")
connection <- file(fastaFile, open="r")
# Get first line of file
firstLine <- readLines(connection, n=1)
# Close file connection
close(connection)
# Get the number of sites used in the FASTA file from first line
nSites <- as.numeric(strsplit(firstLine, " ")[[1]][2])
return(nSites)
}
getConstantSiteCounts <- function(constantSiteCountsFile){
# Open the file and store the file lines
connection <- file(constantSiteCountsFile, "r")
lines <- readLines(connection)
close(connection)
# Calculate the constant site counts
counts <- c(0,0,0,0)
for(line in lines){
# Skip lines without counts
if(grepl(line, pattern="Counts|A") == TRUE || line == ""){
next
}
# Split the line into its parts
parts <- strsplit(line, "\t")[[1]]
# Add the counts to the tally
counts <- counts + as.numeric(parts)
}
return(counts)
}
path <- "/home/josephcrispell/Desktop/Research/Cumbria/"
#### Note the Genome Size examined ####
# Get the constant site counts
constantSiteCountsFile <- paste(path, "TVR_vcfFiles/", "constantSiteCounts_29-03-2019.txt",
sep="")
constantSiteCounts <- getConstantSiteCounts(constantSiteCountsFile)
genomeSize <- sum(constantSiteCounts)
# Get number of sites used in FASTA file
fastaFile <- paste(path, "TVR_vcfFiles/", "sequences_Prox-10_29-03-2019.fasta", sep="")
nSites <- getNSitesInFASTA(fastaFile)
genomeSize <- genomeSize + nSites
# Move the path
path <- paste(path, "BASTA/", sep="")
# Note the date when all analyses were created
date <- "10-05-19"
# Set the number of replicates
nReplicates <- 2
# Note the deme structures that were used in the analyses
demeStructures <- list("4DemeCumbria"=4)
# Note the population size estimation options
popEstimationTypes <- c("varying", "equal")
# Note the clock model options
clockEstimateTypes <- c("relaxed") # strict not used
# Store each of the log tables in a list
logTables <- readInBASTALogTables(date, demeStructures, popEstimationTypes,
clockEstimateTypes, path, nReplicates)
nBootstraps <- 1000
migrationRateEstimates <- summarisePosteriorLogTables(path, logTables, code=2,
arrowFactor=20, nBootstraps,
genomeSize, date)
# Initialise vectors to store summary data for each analysis
medians <- c()
uppers <- c()
lowers <- c()
flags <- c()
names <- c()
index <- 0
# Set the demeStructure
demeStructure <- names(demeStructures)[1]
# Inter-species transmission rates
for(replicate in seq_len(nReplicates)){
# Loop through the population size types
for(popType in c("equal", "varying")){
# Construct the analysis file name
analysis <- paste0(demeStructure, "_", popType, "_relaxed_", replicate, "_", date)
# Examine each of the rates for the current model
for(rate in names(migrationRateEstimates[[analysis]])){
# Ignore the AICM score
if(rate == "AICM"){
next
}
# Get the migration rate values
values <- migrationRateEstimates[[analysis]][[rate]]
# Estimate the flag proportion support
flagSupport <- sum(ifelse(is.na(values), 0, 1)) / length(values)
# Calculate median of the values
median <- median(values, na.rm=TRUE)
# Calculate the upper and lower bounds
quantiles <- quantile(values, probs=c(0.025, 0.975), na.rm=TRUE)
# Store all the values calculated
index <- index + 1
medians[index] <- median
uppers[index] <- quantiles[2]
lowers[index] <- quantiles[1]
flags[index] <- flagSupport
names[index] <- paste0(analysis, "_", rate)
}
}
}
plotLocations <- list("badgerCumbria-to-cowCumbria_equal_1"=0.85,
"badgerCumbria-to-cowCumbria_equal_2"=0.95,
"badgerCumbria-to-cowCumbria_varying_1"=1.05,
"badgerCumbria-to-cowCumbria_varying_2"=1.15,
"cowCumbria-to-badgerCumbria_equal_1"=1.85,
"cowCumbria-to-badgerCumbria_equal_2"=1.95,
"cowCumbria-to-badgerCumbria_varying_1"=2.05,
"cowCumbria-to-badgerCumbria_varying_2"=2.15,
"badgerTVR-to-cowTVR_equal_1"=2.85,
"badgerTVR-to-cowTVR_equal_2"=2.95,
"badgerTVR-to-cowTVR_varying_1"=3.05,
"badgerTVR-to-cowTVR_varying_2"=3.15,
"cowTVR-to-badgerTVR_equal_1"=3.85,
"cowTVR-to-badgerTVR_equal_2"=3.95,
"cowTVR-to-badgerTVR_varying_1"=4.05,
"cowTVR-to-badgerTVR_varying_2"=4.15,
"cowTVR-to-cowCumbria_equal_1"=4.85,
"cowTVR-to-cowCumbria_equal_2"=4.95,
"cowTVR-to-cowCumbria_varying_1"=5.05,
"cowTVR-to-cowCumbria_varying_2"=5.15)
# Create an empty plot
yRange <- range(c(lowers, uppers))
plot(x=NULL, y=NULL, ylim=log(yRange), xlim=c(0.5, 5.5), bty="n", las=1,
xaxt="n", ylab="Per lineage transition rate per year", xlab="", yaxt="n")
# Add the Y labels
at <- c(yRange[1], 0.001, 0.01, 0.1, 1.5)
axis(side=2, at=log(at), labels=round(at, digits=3), las=1, xpd=TRUE, line=-0.2)
# Add the X axis labels
labels <- c("badger-to-cattle", "cattle-to-badger", "badger-to-cattle", "cattle-to-badger",
"NI-to-Cumbria")
axis(side=1, at=1:5, labels=labels)
axis(side=1, at=c(1.5, 3.5), labels=c("Cumbria", "Northern Ireland (NI)"), tick=FALSE, line=2)
# Loop through each analysis
for(index in seq_along(names)){
# Get the location on the X axis for the current analysis
parts <- strsplit(names[index], split="_")[[1]]
replicate <- as.numeric(parts[4])
from <- getDemeNamesForDemeStructure("4DemeCumbria", as.numeric(parts[6]))
to <- getDemeNamesForDemeStructure("4DemeCumbria", as.numeric(parts[7]))
position <- plotLocations[[paste0(from, "-to-", to, "_", parts[2], "_", replicate)]]
# Plot the a summary of the distribution
points(x=c(position, position), y=log(c(lowers[index], uppers[index])), type="l", lwd=2,
col=ifelse(parts[2] == "varying", "grey", "black"))
points(x=position, y=log(medians[index]), pch=19)
}
setAlpha <- function(colours, alpha){
# Check alpha value is from 0 to 1
if(alpha < 0 || alpha > 1){
stop("The alpha value must be from 0 to 1.")
}
# Create a vector to store the output colours
output <- c()
# Examine each colour provided
for(index in seq_along(colours)){
# Convert the current colour into rgb values
rgbValues <- col2rgb(colour)
# Place rgb values within rgb function and insert alpha value
# Note that col2rgb returns rgbvlues from 0 to 255
output[index] <- rgb(rgbValues["red", 1], rgbValues["green", 1], rgbValues["blue", 1],
alpha=alpha*255, maxColorValue=255)
}
return(output)
}
setAlpha("green", alpha=0.5)
setAlpha <- function(colours, alpha){
# Check alpha value is from 0 to 1
if(alpha < 0 || alpha > 1){
stop("The alpha value must be from 0 to 1.")
}
# Create a vector to store the output colours
output <- c()
# Examine each colour provided
for(index in seq_along(colours)){
# Convert the current colour into rgb values
rgbValues <- col2rgb(colours[index])
# Place rgb values within rgb function and insert alpha value
# Note that col2rgb returns rgbvlues from 0 to 255
output[index] <- rgb(rgbValues["red", 1], rgbValues["green", 1], rgbValues["blue", 1],
alpha=alpha*255, maxColorValue=255)
}
return(output)
}
setAlpha("green", alpha=0.5)
# Define the coordinates of three points
x <- c(0.1, 0.5, 0.9)
y <- c(0.5, 0.5, 0.5)
# Define the colours for the points
colours <- c("green", "blue", "red")
# Plot the points - set the transparency
plot(x, y, bty="n", xlab="X", ylab="Y", las=1, pch=19, cex=2,
col=setAlpha(colours, alpha=0.5))
x <- c(0.1, 0.5, 0.9)
y <- c(0.5, 0.5, 0.5)
# Define the colours for the points
colours <- c("green", "blue", "red")
# Plot the points - set the transparency
plot(x, y, bty="n", xlab="X", ylab="Y", las=1, pch=19, cex=4, xlim=c(0,1), ylim=c(0,1),
col=setAlpha(colours, alpha=0.5))
# Define the coordinates of three points
x <- c(0.1, 0.5, 0.9)
y <- c(0.5, 0.5, 0.5)
# Define the colours for the points
colours <- c("green", "blue", "red")
# Plot the points - set the transparency
plot(x, y, bty="n", xlab="X", ylab="Y", las=1, pch=19, cex=10, xlim=c(0,1), ylim=c(0,1),
col=setAlpha(colours, alpha=0.5))
# Define the coordinates of three points
x <- c(0.1, 0.5, 0.9)
y <- c(0.5, 0.5, 0.5)
# Define the colours for the points
colours <- c("green", "blue", "red")
# Plot the points - set the transparency
plot(x, y, bty="n", xlab="X", ylab="Y", las=1, pch=19, cex=30, xlim=c(0,1), ylim=c(0,1),
col=setAlpha(colours, alpha=0.5))
# Define the coordinates of three points
x <- c(0.1, 0.5, 0.9)
y <- c(0.5, 0.5, 0.5)
# Define the colours for the points
colours <- c("green", "blue", "red")
# Plot the points - set the transparency
plot(x, y, bty="n", xlab="X", ylab="Y", las=1, pch=19, cex=30, xaxt="n", yaxt="n",
col=setAlpha(colours, alpha=0.5))
# Define the coordinates of three points
x <- c(0.1, 0.5, 0.9)
y <- c(0.5, 0.5, 0.5)
# Define the colours for the points
colours <- c("green", "blue", "red")
# Plot the points - set the transparency
plot(x, y, bty="n", xlab="X", ylab="Y", las=1, pch=19, cex=30, xlim=c(0,1), ylim=c(0,1),
col=setAlpha(colours, alpha=0.5))
# Define the coordinates of three points
x <- c(0.4, 0.5, 0.6)
y <- c(0.5, 0.5, 0.5)
# Define the colours for the points
colours <- c("green", "blue", "red")
# Plot the points - set the transparency
plot(x, y, bty="n", xlab="X", ylab="Y", las=1, pch=19, cex=5, xlim=c(0,1), ylim=c(0,1),
col=setAlpha(colours, alpha=0.5))
# Define the coordinates of three points
x <- c(0.4, 0.5, 0.6)
y <- c(0.5, 0.5, 0.5)
# Define the colours for the points
colours <- c("green", "blue", "red")
# Plot the points - set the transparency
plot(x, y, bty="n", xlab="X", ylab="Y", las=1, pch=19, cex=10, xlim=c(0,1), ylim=c(0,1),
col=setAlpha(colours, alpha=0.5))
# Define the coordinates of three points
x <- c(0.3, 0.5, 0.7)
y <- c(0.5, 0.5, 0.5)
# Define the colours for the points
colours <- c("green", "blue", "red")
# Plot the points - set the transparency
plot(x, y, bty="n", xlab="X", ylab="Y", las=1, pch=19, cex=10, xlim=c(0,1), ylim=c(0,1),
col=setAlpha(colours, alpha=0.5))
# Define the coordinates of three points
x <- c(0.2, 0.5, 0.8)
y <- c(0.5, 0.5, 0.5)
# Define the colours for the points
colours <- c("green", "blue", "red")
# Plot the points - set the transparency
plot(x, y, bty="n", xlab="X", ylab="Y", las=1, pch=19, cex=30, xlim=c(0,1), ylim=c(0,1),
col=setAlpha(colours, alpha=0.5))
library("devtools")
library("roxygen2")
packageDirectory <- "/home/josephcrispell/Desktop/Research/basicPlotteR/"
setwd(packageDirectory)
document()
library("devtools")
library("roxygen2")
packageDirectory <- "/home/josephcrispell/Desktop/Research/basicPlotteR/"
setwd(packageDirectory)
document()
devtools::install_github("JosephCrispell/basicPlotteR")
library(basicPlotteR)
# Set the seed
set.seed(254534)
# Generate some example points - drawn from exponential distribution
values <- rexp(n=50, rate=2)
# Plot a boxplot
boxplot(values, xlab="",  ylab="", frame=FALSE, las=1, pch=19, outcol=rgb(1,0,0, 0.5),
horizontal=FALSE)
# Plot the points spread along the X axis
spreadPoints(values, position=1)
# Set the seed
set.seed(254534)
# Generate some example points - drawn from exponential distribution
values <- rexp(n=50, rate=2)
# Plot a boxplot
boxplot(values, xlab="",  ylab="", frame=FALSE, las=1, pch=19, outcol=rgb(1,0,0, 0.5),
horizontal=FALSE)
# Plot the points spread along the X axis
spreadPoints(values, position=1)
?spreadPoints
