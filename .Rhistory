return(output)
}
getDemeNamesForDemeStructure <- function(demeStructure, number=NULL){
# Species-InOrOut-Location
# badger  inner   east
# cow     outer   west
#                 north
#                 south
demeNames <- list(
"2Deme"=c("badger", "cow"),
"3Deme-outerIsBoth"=c("badger-inner", "cow-inner", "outer"),
"3Deme-outerIsBadger"=c("badger-inner", "cow", "unsampled"),
"3Deme-outerIsCattle"=c("badger", "cow-inner", "cow-outer"),
"4Deme"=c("badger-inner", "cow-inner", "cow-outer", "unsampled"),
"6Deme-EastWest"=c("badger-inner", "cow-inner", "cow-outer-east", "cow-outer-west", "unsampled-1", "unsampled-2"),
"6Deme-NorthSouth"=c("badger-inner", "cow-inner", "cow-outer-north", "cow-outer-south", "unsampled-1", "unsampled-2"),
"8Deme-EastWest"=c("badger-inner-east", "badger-inner-west", "cow-inner-east", "cow-inner-west",
"cow-outer-east", "cow-outer-west", "unsampled-1", "unsampled-2"),
"8Deme-NorthSouth"=c("badger-inner-north", "badger-inner-south", "cow-inner-north", "cow-inner-south",
"cow-outer-north", "cow-outer-south", "unsampled-1", "unsampled-2")
)
output = demeNames[[demeStructure]]
if(is.null(number) == FALSE){
output = demeNames[[demeStructure]][number + 1]
}
return(output)
}
readInBASTALogTables <- function(date, demeStructures, popEstimationTypes,
clockEstimateTypes, path, burnInProp=0.1,
nReplicates=NULL, ignoreIfFlagged=FALSE){
# Store each of the log tables in a list
logTables <- list()
for(demeStructure in names(demeStructures)){
for(popEstimationType in popEstimationTypes){
for(clockEstimationType in clockEstimateTypes){
# Build run defining prefix
prefix <- paste(demeStructure, "_", popEstimationType, "_",
clockEstimationType, "_", date, sep="")
# Initilialise a list to store the log tables for the current run's replicates
logTablesForReplicates <- list()
# Check if repliocates available
if(is.null(nReplicates) == FALSE){
# Retrieve the data from each replicate
for(replicate in 1:nReplicates){
# Print progress information
cat(paste("\rReading: ", prefix, ".log\tReplicate: ", replicate,
"\t\t\t\t\t", sep=""))
# Create file name
file <- paste(path, "Replicate", replicate, "_", date, "/",
prefix, "/", prefix, ".log", sep="")
# Read in the file as table
logTable <- read.table(file, header=TRUE, sep="\t", stringsAsFactors=FALSE)
# Replace "N" in table with NAs
logTable[logTable == "N"] <- NA
# Remove the burn-in
burnIn <- round(burnInProp * nrow(logTable), digits=0)
logTable <- logTable[burnIn:nrow(logTable), ]
# Calculate the forward rates
logTable <- calculateForwardMigrationRates(logTable)
# Store the logTable
logTablesForReplicates[[as.character(replicate)]] <- logTable
}
# Store the tables as a single log table
logTables[[prefix]] <- combineLogTables(logTablesForReplicates)
}else{
# Print progress information
cat(paste("\rReading: ", prefix, ".log\t\t\t\t\t\t", sep=""))
# Create file name
file <- paste(path, prefix, "/", prefix, ".log", sep="")
# Read in the file as table
logTable <- read.table(file, header=TRUE, sep="\t", stringsAsFactors=FALSE)
# Replace "N" in table with NAs
logTable[logTable == "N"] <- NA
# Remove the burn-in
burnIn <- round(burnInProp * nrow(logTable), digits=0)
logTable <- logTable[burnIn:nrow(logTable), ]
# Calculate the forward rates
logTable <- calculateForwardMigrationRates(logTable)
# Store the tables as a single log table
logTables[[prefix]] <- logTable
}
}
}
}
cat("\rFinished reading in log tables...\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n")
return(logTables)
}
combineLogTables <- function(logTablesForReplicates){
output <- logTablesForReplicates[[1]]
if(length(logTablesForReplicates) > 1){
for(i in 2:length(logTablesForReplicates)){
output <- rbind(output, logTablesForReplicates[[i]])
}
}
return(output)
}
# Text overlay functions
overlayText <- function(x, y, labels, cex){
###########################################
# Produce a list of alternative locations #
###########################################
# Get the axis limits
axisLimits <- par("usr")
# Get the text label heights and lengths
textHeights <- strheight(labels) * cex
textWidths <- strwidth(labels) * cex
# Define the spacer for each axis
spacerX <- 0.01 * (axisLimits[2] - axisLimits[1])
spacerY <- 0.01 * (axisLimits[4] - axisLimits[3])
# Generate the set of points based upon the spacer
altX <- c()
altY <- c()
for(i in seq(axisLimits[1], axisLimits[2], spacerX)){
for(j in seq(axisLimits[3], axisLimits[4], spacerY)){
altX[length(altX) + 1] <- i
altY[length(altY) + 1] <- j
}
}
#points(altX, altY, col=rgb(0,0,0, 0.5), pch=20, xpd=TRUE)
# Remove points that are too close to actual values
remove <- c()
for(i in 1:length(altX)){
for(j in 1:length(x)){
if(abs(altX[i] - x[j]) < textWidths[j] &&
abs(altY[i] - y[j]) < textHeights[j]){
remove[length(remove) + 1] <- i
break
}
}
}
#points(altX[remove], altY[remove], col=rgb(1,1,1), pch=20, xpd=TRUE)
if(length(remove) > 0){
altX <- altX[-remove]
altY <- altY[-remove]
}
##############################################################
# Add labels to plot assigning new locations where necessary #
##############################################################
# Plot the point label
for(i in 1:length(x)){
# Is the current point too close to others?
if(tooClose(x, y, i, textHeights[i], textWidths[i]) == TRUE && length(altX) != 0){
# Get a new location
newLocationIndex <- chooseNewLocation(x[i], y[i], altX, altY)
# Add label
text(x=altX[newLocationIndex], y=altY[newLocationIndex],
labels=labels[i], xpd=TRUE, cex=cex)
# Add line back to previous location
points(x=c(altX[newLocationIndex], x[i]),
y=c(altY[newLocationIndex], y[i]),
type="l", col=rgb(0,0,0, 0.5))
# Remove new location and any locations too close to it
output <- removeLocationAndThoseCloseToItFromAlternatives(
altX, altY, newLocationIndex, textHeights[i], textWidths[i])
altX <- output[["X"]]
altY <- output[["Y"]]
}else{
text(x=x[i], y=y[i],
labels=labels[i], xpd=TRUE, cex=cex)
}
}
}
removeLocationAndThoseCloseToItFromAlternatives <- function(altX, altY, index, textHeight, textWidth){
remove <- c(index)
for(i in 1:length(altX)){
if(i == index){
next
}
if(abs(altX[index] - altX[i]) < textWidth &&
abs(altY[index] - altY[i]) < textHeight){
remove[length(remove) + 1] <- i
}
}
altX <- altX[-remove]
altY <- altY[-remove]
return(list("X" = altX, "Y" = altY))
}
chooseNewLocation <- function(x, y, altXs, altYs){
# Calculate the distance from point to all alternatives
distances <- c()
for(i in 1:length(altXs)){
distances[i] <- euclideanDistance(x, y, altXs[i], altYs[i])
}
return(which.min(distances))
}
tooClose <- function(x, y, index, textHeight, textWidth){
result <- FALSE
for(i in 1:length(x)){
if(i == index){
next
}else if(abs(x[index] - x[i]) < textWidth &&
abs(y[index] - y[i]) < textHeight){
result <- TRUE
break
}
}
return(result)
}
euclideanDistance <- function(x1, y1, x2, y2){
return(sqrt(sum((x1 - x2)^2 + (y1 - y2)^2)))
}
getConstantSiteCounts <- function(constantSiteCountsFile){
# Open the file and store the file lines
connection <- file(constantSiteCountsFile, "r")
lines <- readLines(connection)
close(connection)
# Calculate the constant site counts
counts <- c(0,0,0,0)
for(line in lines){
# Skip lines without counts
if(grepl(line, pattern="Counts|A") == TRUE || line == ""){
next
}
# Split the line into its parts
parts <- strsplit(line, "\t")[[1]]
# Add the counts to the tally
counts <- counts + as.numeric(parts)
}
return(counts)
}
getNSitesInFASTA <- function(fastaFile){
# Open a connection to a file to read (open="r")
connection <- file(fastaFile, open="r")
# Get first line of file
firstLine <- readLines(connection, n=1)
# Close file connection
close(connection)
# Get the number of sites used in the FASTA file from first line
nSites <- as.numeric(strsplit(firstLine, " ")[[1]][2])
return(nSites)
}
constantSiteCountsFile <- paste(path, "TVR_vcfFiles/", "constantSiteCounts_29-03-2019.txt",
sep="")
constantSiteCounts <- getConstantSiteCounts(constantSiteCountsFile)
genomeSize <- sum(constantSiteCounts)
# Get number of sites used in FASTA file
fastaFile <- paste(path, "TVR_vcfFiles/", "sequences_Prox-10_29-03-2019.fasta", sep="")
nSites <- getNSitesInFASTA(fastaFile)
genomeSize <- genomeSize + nSites
# Set the path
path <- "/home/josephcrispell/Desktop/Research/Cumbria/"
#### Note the Genome Size examined ####
# Get the constant site counts
constantSiteCountsFile <- paste(path, "TVR_vcfFiles/", "constantSiteCounts_29-03-2019.txt",
sep="")
constantSiteCounts <- getConstantSiteCounts(constantSiteCountsFile)
genomeSize <- sum(constantSiteCounts)
# Get number of sites used in FASTA file
fastaFile <- paste(path, "TVR_vcfFiles/", "sequences_Prox-10_29-03-2019.fasta", sep="")
nSites <- getNSitesInFASTA(fastaFile)
genomeSize <- genomeSize + nSites
# Move the path
path <- paste(path, "BASTA/", sep="")
# Note the date when all analyses were created
date <- "10-05-19"
# Note the population size estimation options
popEstimationTypes <- c("varying", "equal")
# Note the clock model options
clockEstimateTypes <- c("relaxed") # strict not used
# Store each of the log tables in a list
logTables <- readInBASTALogTables(date, demeStructures, popEstimationTypes,
clockEstimateTypes, path, nReplicates=2)
# Note the deme structures that were used in the analyses
demeStructures <- c("4DemeCumbria")
# Note the population size estimation options
popEstimationTypes <- c("varying", "equal")
# Note the clock model options
clockEstimateTypes <- c("relaxed") # strict not used
# Store each of the log tables in a list
logTables <- readInBASTALogTables(date, demeStructures, popEstimationTypes,
clockEstimateTypes, path, nReplicates=2)
names(logTables)
nReplicates=2
patjh
path
demeStructure <- demeStructures[1]
popEstimationType <- popEstimationTypes[1]
clockEstimateType <- clockEstimateTypes[1]
replicate <- 1
# Build run defining prefix
prefix <- paste(demeStructure, "_", popEstimationType, "_",
clockEstimationType, "_", replicate, "_", date, sep="")
clockEstimationType <- clockEstimateTypes[1]
# Build run defining prefix
prefix <- paste(demeStructure, "_", popEstimationType, "_",
clockEstimationType, "_", replicate, "_", date, sep="")
prefix
# Create file name
file <- paste(path, "Replicate", replicate, "_", date, "/",
prefix, "/", prefix, ".log", sep="")
file
# Read in the file as table
logTable <- read.table(file, header=TRUE, sep="\t", stringsAsFactors=FALSE)
# Replace "N" in table with NAs
logTable[logTable == "N"] <- NA
# Remove the burn-in
burnIn <- round(burnInProp * nrow(logTable), digits=0)
burnInProp <- 0.1
# Remove the burn-in
burnIn <- round(burnInProp * nrow(logTable), digits=0)
logTable <- logTable[burnIn:nrow(logTable), ]
# Calculate the forward rates
logTable <- calculateForwardMigrationRates(logTable)
# Initilialise a list to store the log tables for the current run's replicates
logTablesForReplicates <- list()
# Store each of the log tables in a list
logTables <- list()
# Loop through the deme structures
for(demeStructure in names(demeStructures)){
# Loop through the population structures
for(popEstimationType in popEstimationTypes){
# Loop through the clock models
for(clockEstimationType in clockEstimateTypes){
# Initilialise a list to store the log tables for the current run's replicates
logTablesForReplicates <- list()
# Retrieve the data from each replicate
for(replicate in 1:nReplicates){
# Build run defining prefix
prefix <- paste(demeStructure, "_", popEstimationType, "_",
clockEstimationType, "_", replicate, "_", date, sep="")
# Print progress information
cat(paste("\rReading: ", prefix, ".log\tReplicate: ", replicate,
"\t\t\t\t\t", sep=""))
# Create file name
file <- paste(path, "Replicate", replicate, "_", date, "/",
prefix, "/", prefix, ".log", sep="")
# Read in the file as table
logTable <- read.table(file, header=TRUE, sep="\t", stringsAsFactors=FALSE)
# Replace "N" in table with NAs
logTable[logTable == "N"] <- NA
# Remove the burn-in
burnIn <- round(burnInProp * nrow(logTable), digits=0)
logTable <- logTable[burnIn:nrow(logTable), ]
# Calculate the forward rates
logTable <- calculateForwardMigrationRates(logTable)
# Store the logTable
logTables[[prefix]] <- logTable
}
}
}
}
logTables
names(demeStructures)
# Note the deme structures that were used in the analyses
demeStructures <- list("4DemeCumbria"=4)
# Store each of the log tables in a list
logTables <- list()
# Loop through the deme structures
for(demeStructure in names(demeStructures)){
# Loop through the population structures
for(popEstimationType in popEstimationTypes){
# Loop through the clock models
for(clockEstimationType in clockEstimateTypes){
# Initilialise a list to store the log tables for the current run's replicates
logTablesForReplicates <- list()
# Retrieve the data from each replicate
for(replicate in 1:nReplicates){
# Build run defining prefix
prefix <- paste(demeStructure, "_", popEstimationType, "_",
clockEstimationType, "_", replicate, "_", date, sep="")
# Print progress information
cat(paste("\rReading: ", prefix, ".log\tReplicate: ", replicate,
"\t\t\t\t\t", sep=""))
# Create file name
file <- paste(path, "Replicate", replicate, "_", date, "/",
prefix, "/", prefix, ".log", sep="")
# Read in the file as table
logTable <- read.table(file, header=TRUE, sep="\t", stringsAsFactors=FALSE)
# Replace "N" in table with NAs
logTable[logTable == "N"] <- NA
# Remove the burn-in
burnIn <- round(burnInProp * nrow(logTable), digits=0)
logTable <- logTable[burnIn:nrow(logTable), ]
# Calculate the forward rates
logTable <- calculateForwardMigrationRates(logTable)
# Store the logTable
logTables[[prefix]] <- logTable
}
}
}
}
names(logTables)
# Store each of the log tables in a list
logTables <- readInBASTALogTables(date, demeStructures, popEstimationTypes,
clockEstimateTypes, path, nReplicates=2)
readInBASTALogTables <- function(date, demeStructures, popEstimationTypes,
clockEstimateTypes, path, nReplicates,
burnInProp=0.1, nReplicates=NULL, ignoreIfFlagged=FALSE){
# Store each of the log tables in a list
logTables <- list()
# Loop through the deme structures
for(demeStructure in names(demeStructures)){
# Loop through the population structures
for(popEstimationType in popEstimationTypes){
# Loop through the clock models
for(clockEstimationType in clockEstimateTypes){
# Initilialise a list to store the log tables for the current run's replicates
logTablesForReplicates <- list()
# Retrieve the data from each replicate
for(replicate in 1:nReplicates){
# Build run defining prefix
prefix <- paste(demeStructure, "_", popEstimationType, "_",
clockEstimationType, "_", replicate, "_", date, sep="")
# Print progress information
cat(paste("\rReading: ", prefix, ".log\tReplicate: ", replicate,
"\t\t\t\t\t", sep=""))
# Create file name
file <- paste(path, "Replicate", replicate, "_", date, "/",
prefix, "/", prefix, ".log", sep="")
# Read in the file as table
logTable <- read.table(file, header=TRUE, sep="\t", stringsAsFactors=FALSE)
# Replace "N" in table with NAs
logTable[logTable == "N"] <- NA
# Remove the burn-in
burnIn <- round(burnInProp * nrow(logTable), digits=0)
logTable <- logTable[burnIn:nrow(logTable), ]
# Calculate the forward rates
logTable <- calculateForwardMigrationRates(logTable)
# Store the logTable
logTables[[prefix]] <- logTable
}
}
}
}
cat("\rFinished reading in log tables...\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n")
return(logTables)
}
# Store each of the log tables in a list
logTables <- readInBASTALogTables(date, demeStructures, popEstimationTypes,
clockEstimateTypes, path, nReplicates=2)
# Store each of the log tables in a list
logTables <- list()
# Loop through the deme structures
for(demeStructure in names(demeStructures)){
# Loop through the population structures
for(popEstimationType in popEstimationTypes){
# Loop through the clock models
for(clockEstimationType in clockEstimateTypes){
# Initilialise a list to store the log tables for the current run's replicates
logTablesForReplicates <- list()
# Retrieve the data from each replicate
for(replicate in 1:nReplicates){
# Build run defining prefix
prefix <- paste(demeStructure, "_", popEstimationType, "_",
clockEstimationType, "_", replicate, "_", date, sep="")
# Print progress information
cat(paste("\rReading: ", prefix, ".log\tReplicate: ", replicate,
"\t\t\t\t\t", sep=""))
# Create file name
file <- paste(path, "Replicate", replicate, "_", date, "/",
prefix, "/", prefix, ".log", sep="")
# Read in the file as table
logTable <- read.table(file, header=TRUE, sep="\t", stringsAsFactors=FALSE)
# Replace "N" in table with NAs
logTable[logTable == "N"] <- NA
# Remove the burn-in
burnIn <- round(burnInProp * nrow(logTable), digits=0)
logTable <- logTable[burnIn:nrow(logTable), ]
# Calculate the forward rates
logTable <- calculateForwardMigrationRates(logTable)
# Store the logTable
logTables[[prefix]] <- logTable
}
}
}
}
cat("\rFinished reading in log tables...\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n")
path
readInBASTALogTables <- function(date, demeStructures, popEstimationTypes,
clockEstimateTypes, path, nReplicates,
burnInProp=0.1, ignoreIfFlagged=FALSE){
# Store each of the log tables in a list
logTables <- list()
# Loop through the deme structures
for(demeStructure in names(demeStructures)){
# Loop through the population structures
for(popEstimationType in popEstimationTypes){
# Loop through the clock models
for(clockEstimationType in clockEstimateTypes){
# Initilialise a list to store the log tables for the current run's replicates
logTablesForReplicates <- list()
# Retrieve the data from each replicate
for(replicate in 1:nReplicates){
# Build run defining prefix
prefix <- paste(demeStructure, "_", popEstimationType, "_",
clockEstimationType, "_", replicate, "_", date, sep="")
# Print progress information
cat(paste("\rReading: ", prefix, ".log\tReplicate: ", replicate,
"\t\t\t\t\t", sep=""))
# Create file name
file <- paste(path, "Replicate", replicate, "_", date, "/",
prefix, "/", prefix, ".log", sep="")
# Read in the file as table
logTable <- read.table(file, header=TRUE, sep="\t", stringsAsFactors=FALSE)
# Replace "N" in table with NAs
logTable[logTable == "N"] <- NA
# Remove the burn-in
burnIn <- round(burnInProp * nrow(logTable), digits=0)
logTable <- logTable[burnIn:nrow(logTable), ]
# Calculate the forward rates
logTable <- calculateForwardMigrationRates(logTable)
# Store the logTable
logTables[[prefix]] <- logTable
}
}
}
}
cat("\rFinished reading in log tables...\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n")
return(logTables)
}
logTables <- readInBASTALogTables(date, demeStructures, popEstimationTypes,
clockEstimateTypes, path, nReplicates=2)
