# Get the current column ID
col <- colNames[j]
# Check if row has already been assigned to a cluster
if(is.null(clusters[[row]]) == FALSE && is.null(clusters[[col]]) == TRUE){
# Assign column to same cluster
clusters[[col]] <- clusters[[row]]
# Check if column has already been assigned to a cluster
}else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == FALSE){
# Assign row to same cluster
clusters[[col]] <- clusters[[row]]
# Check if neither row or column have been assigned to a cluster
}else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == TRUE){
# Create a new cluster
cluster <- cluster + 1
# Put both row and olumn into new cluster
clusters[[row]] <- cluster
clusters[[col]] <- cluster
# Check if have been assigned to different clusters!
}else if(clusters[[row]] != clusters[[col]]){
# Merge the individuals into one of the clusters
clusters <- mergeClusters(clusters, clusters[[row]], clusters[[col]])
}
}
}
clusters
matrix
# Create a list to note the cluster each sequence has been assigned
clusters <- list()
cluster <- 0
# Get the row and column namaes
rowNames <- rownames(matrix)
colNames <- colnames(matrix)
# Examine each cell in the matrix
for(i in seq_along(rowNames)){
# Get the current row ID
row <- rowNames[i]
for(j in seq_along(colNames)){
# Skip diagonal, lower part of matrix and any values aboce threshold
if(i >= j ){#|| is.na(matrix[i, j]) || matrix[i, j] > threshold){
next
}
cat(i, "  ", j, "\n")
# # Get the current column ID
# col <- colNames[j]
#
# # Check if row has already been assigned to a cluster
# if(is.null(clusters[[row]]) == FALSE && is.null(clusters[[col]]) == TRUE){
#
#   # Assign column to same cluster
#   clusters[[col]] <- clusters[[row]]
#
# # Check if column has already been assigned to a cluster
# }else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == FALSE){
#
#   # Assign row to same cluster
#   clusters[[col]] <- clusters[[row]]
#
# # Check if neither row or column have been assigned to a cluster
# }else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == TRUE){
#
#   # Create a new cluster
#   cluster <- cluster + 1
#
#   # Put both row and olumn into new cluster
#   clusters[[row]] <- cluster
#   clusters[[col]] <- cluster
#
# # Check if have been assigned to different clusters!
# }else if(clusters[[row]] != clusters[[col]]){
#
#   # Merge the individuals into one of the clusters
#   clusters <- mergeClusters(clusters, clusters[[row]], clusters[[col]])
# }
}
}
matrix
# Create a list to note the cluster each sequence has been assigned
clusters <- list()
cluster <- 0
# Get the row and column namaes
rowNames <- rownames(matrix)
colNames <- colnames(matrix)
# Examine each cell in the matrix
for(i in seq_along(rowNames)){
# Get the current row ID
row <- rowNames[i]
for(j in seq_along(colNames)){
# Skip diagonal, lower part of matrix and any values aboce threshold
if(i >= j || is.na(matrix[i, j]) ){#|| matrix[i, j] > threshold){
next
}
cat(i, "  ", j, "\n")
# # Get the current column ID
# col <- colNames[j]
#
# # Check if row has already been assigned to a cluster
# if(is.null(clusters[[row]]) == FALSE && is.null(clusters[[col]]) == TRUE){
#
#   # Assign column to same cluster
#   clusters[[col]] <- clusters[[row]]
#
# # Check if column has already been assigned to a cluster
# }else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == FALSE){
#
#   # Assign row to same cluster
#   clusters[[col]] <- clusters[[row]]
#
# # Check if neither row or column have been assigned to a cluster
# }else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == TRUE){
#
#   # Create a new cluster
#   cluster <- cluster + 1
#
#   # Put both row and olumn into new cluster
#   clusters[[row]] <- cluster
#   clusters[[col]] <- cluster
#
# # Check if have been assigned to different clusters!
# }else if(clusters[[row]] != clusters[[col]]){
#
#   # Merge the individuals into one of the clusters
#   clusters <- mergeClusters(clusters, clusters[[row]], clusters[[col]])
# }
}
}
# Create a list to note the cluster each sequence has been assigned
clusters <- list()
cluster <- 0
# Get the row and column namaes
rowNames <- rownames(matrix)
colNames <- colnames(matrix)
# Examine each cell in the matrix
for(i in seq_along(rowNames)){
# Get the current row ID
row <- rowNames[i]
for(j in seq_along(colNames)){
# Skip diagonal, lower part of matrix and any values aboce threshold
if(i >= j || is.na(matrix[i, j]) || matrix[i, j] > threshold){
next
}
cat(i, "  ", j, "\n")
# # Get the current column ID
# col <- colNames[j]
#
# # Check if row has already been assigned to a cluster
# if(is.null(clusters[[row]]) == FALSE && is.null(clusters[[col]]) == TRUE){
#
#   # Assign column to same cluster
#   clusters[[col]] <- clusters[[row]]
#
# # Check if column has already been assigned to a cluster
# }else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == FALSE){
#
#   # Assign row to same cluster
#   clusters[[col]] <- clusters[[row]]
#
# # Check if neither row or column have been assigned to a cluster
# }else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == TRUE){
#
#   # Create a new cluster
#   cluster <- cluster + 1
#
#   # Put both row and olumn into new cluster
#   clusters[[row]] <- cluster
#   clusters[[col]] <- cluster
#
# # Check if have been assigned to different clusters!
# }else if(clusters[[row]] != clusters[[col]]){
#
#   # Merge the individuals into one of the clusters
#   clusters <- mergeClusters(clusters, clusters[[row]], clusters[[col]])
# }
}
}
matrix
cluster
i <- 2
j <- 4
# Get the current row ID
row <- rowNames[i]
i >= j || is.na(matrix[i, j]) || matrix[i, j] > threshold
# Get the current column ID
col <- colNames[j]
cat(i, "  ", j, "\n")
is.null(clusters[[row]])
is.null(clusters[[col]])
is.null(clusters[[row]]) == FALSE && is.null(clusters[[col]]) == TRUE
is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == FALSE
is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == TRUE
# Create a new cluster
cluster <- cluster + 1
# Put both row and olumn into new cluster
clusters[[row]] <- cluster
clusters[[col]] <- cluster
clusters
i <- 3
# Get the current row ID
row <- rowNames[i]
matrix[i, j]
threshold
i >= j || is.na(matrix[i, j]) || matrix[i, j] > threshold
is.null(clusters[[row]])
is.null(clusters[[col]])
is.null(clusters[[row]])
is.null(clusters[[row]]) == FALSE && is.null(clusters[[col]]) == TRUE
is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == FALSE
# Assign row to same cluster
clusters[[row]] <- clusters[[col]]
clusters
getClustersFromMatrixWithThreshold <- function(matrix, threshold){
# Create a list to note the cluster each sequence has been assigned
clusters <- list()
cluster <- 0
# Get the row and column namaes
rowNames <- rownames(matrix)
colNames <- colnames(matrix)
# Examine each cell in the matrix
for(i in seq_along(rowNames)){
# Get the current row ID
row <- rowNames[i]
for(j in seq_along(colNames)){
# Skip diagonal, lower part of matrix and any values aboce threshold
if(i >= j || is.na(matrix[i, j]) || matrix[i, j] > threshold){
next
}
cat(i, "  ", j, "\n")
# Get the current column ID
col <- colNames[j]
# Check if row has already been assigned to a cluster
if(is.null(clusters[[row]]) == FALSE && is.null(clusters[[col]]) == TRUE){
# Assign column to same cluster
clusters[[col]] <- clusters[[row]]
# Check if column has already been assigned to a cluster
}else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == FALSE){
# Assign row to same cluster
clusters[[row]] <- clusters[[col]]
# Check if neither row or column have been assigned to a cluster
}else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == TRUE){
# Create a new cluster
cluster <- cluster + 1
# Put both row and olumn into new cluster
clusters[[row]] <- cluster
clusters[[col]] <- cluster
# Check if have been assigned to different clusters!
}else if(clusters[[row]] != clusters[[col]]){
# Merge the individuals into one of the clusters
clusters <- mergeClusters(clusters, clusters[[row]], clusters[[col]])
}
}
}
# Initialise an output data.frame recording each sequences cluster
clusterTable <- data.frame("SequenceID"=rownames(matrix), "Cluster"=NA, stringsAsFactors=FALSE)
# Retrieve the cluster assignments from the clusters list
for(sequenceID in names(clusters)){
# Find row in cluster table
row <- which(clusterTable$SequenceID == sequenceID)
# Assign the cluster
clusterTable[row, "Cluster"] <- clusters[[sequenceID]]
}
# Remove NA rows
clusterTable <- clusterTable[is.na(clusterTable$Cluster) == FALSE, ]
return(clusterTable)
}
# Define genetic distance clusters based on threshold
geneticClusters <- getClustersFromMatrixWithThreshold(geneticDistances, snpThreshold)
getClustersFromMatrixWithThreshold <- function(matrix, threshold){
# Create a list to note the cluster each sequence has been assigned
clusters <- list()
cluster <- 0
# Get the row and column namaes
rowNames <- rownames(matrix)
colNames <- colnames(matrix)
# Examine each cell in the matrix
for(i in seq_along(rowNames)){
# Get the current row ID
row <- rowNames[i]
for(j in seq_along(colNames)){
# Skip diagonal, lower part of matrix and any values aboce threshold
if(i >= j || is.na(matrix[i, j]) || matrix[i, j] > threshold){
next
}
# Get the current column ID
col <- colNames[j]
# Check if row has already been assigned to a cluster
if(is.null(clusters[[row]]) == FALSE && is.null(clusters[[col]]) == TRUE){
# Assign column to same cluster
clusters[[col]] <- clusters[[row]]
# Check if column has already been assigned to a cluster
}else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == FALSE){
# Assign row to same cluster
clusters[[row]] <- clusters[[col]]
# Check if neither row or column have been assigned to a cluster
}else if(is.null(clusters[[row]]) == TRUE && is.null(clusters[[col]]) == TRUE){
# Create a new cluster
cluster <- cluster + 1
# Put both row and olumn into new cluster
clusters[[row]] <- cluster
clusters[[col]] <- cluster
# Check if have been assigned to different clusters!
}else if(clusters[[row]] != clusters[[col]]){
# Merge the individuals into one of the clusters
clusters <- mergeClusters(clusters, clusters[[row]], clusters[[col]])
}
}
}
# Initialise an output data.frame recording each sequences cluster
clusterTable <- data.frame("SequenceID"=rownames(matrix), "Cluster"=NA, stringsAsFactors=FALSE)
# Retrieve the cluster assignments from the clusters list
for(sequenceID in names(clusters)){
# Find row in cluster table
row <- which(clusterTable$SequenceID == sequenceID)
# Assign the cluster
clusterTable[row, "Cluster"] <- clusters[[sequenceID]]
}
# Remove NA rows
clusterTable <- clusterTable[is.na(clusterTable$Cluster) == FALSE, ]
return(clusterTable)
}
# Define genetic distance clusters based on threshold
geneticClusters <- getClustersFromMatrixWithThreshold(geneticDistances, snpThreshold)
clusters <- geneticClusters
# Add a sub cluster column to the clusters table
clusters$SubSpatialCluster <- NA
# Examine each cluster
for(cluster in unique(clusters$Cluster)){
# Get the isolate IDs for the current cluster
isolates <- clusters[clusters$Cluster == cluster, "SequenceID"]
# Get a spatial distance matrix for the current cluster
matrix <- getSpatialDistancesForCluster(isolates, distances)
# Identify any sub-clusters based upon spatial distances
subClusters <- getClustersFromMatrixWithThreshold(matrix, threshold)
# Assign the subclusters
for(row in seq_len(nrow(subClusters))){
clusters$SubSpatialCluster[which(clusters$SequenceID == subClusters[row, "SequenceID"])] <- subClusters[row, "Cluster"]
}
}
clusters
threshold <- 2000
# Add a sub cluster column to the clusters table
clusters$SubSpatialCluster <- NA
# Examine each cluster
for(cluster in unique(clusters$Cluster)){
# Get the isolate IDs for the current cluster
isolates <- clusters[clusters$Cluster == cluster, "SequenceID"]
# Get a spatial distance matrix for the current cluster
matrix <- getSpatialDistancesForCluster(isolates, distances)
# Identify any sub-clusters based upon spatial distances
subClusters <- getClustersFromMatrixWithThreshold(matrix, threshold)
# Assign the subclusters
for(row in seq_len(nrow(subClusters))){
clusters$SubSpatialCluster[which(clusters$SequenceID == subClusters[row, "SequenceID"])] <- subClusters[row, "Cluster"]
}
}
clusters
threshold <- 3000
# Add a sub cluster column to the clusters table
clusters$SubSpatialCluster <- NA
# Examine each cluster
for(cluster in unique(clusters$Cluster)){
# Get the isolate IDs for the current cluster
isolates <- clusters[clusters$Cluster == cluster, "SequenceID"]
# Get a spatial distance matrix for the current cluster
matrix <- getSpatialDistancesForCluster(isolates, distances)
# Identify any sub-clusters based upon spatial distances
subClusters <- getClustersFromMatrixWithThreshold(matrix, threshold)
# Assign the subclusters
for(row in seq_len(nrow(subClusters))){
clusters$SubSpatialCluster[which(clusters$SequenceID == subClusters[row, "SequenceID"])] <- subClusters[row, "Cluster"]
}
}
clusters
threshold <- 2500
# Add a sub cluster column to the clusters table
clusters$SubSpatialCluster <- NA
# Examine each cluster
for(cluster in unique(clusters$Cluster)){
# Get the isolate IDs for the current cluster
isolates <- clusters[clusters$Cluster == cluster, "SequenceID"]
# Get a spatial distance matrix for the current cluster
matrix <- getSpatialDistancesForCluster(isolates, distances)
# Identify any sub-clusters based upon spatial distances
subClusters <- getClustersFromMatrixWithThreshold(matrix, threshold)
# Assign the subclusters
for(row in seq_len(nrow(subClusters))){
clusters$SubSpatialCluster[which(clusters$SequenceID == subClusters[row, "SequenceID"])] <- subClusters[row, "Cluster"]
}
}
clusters
examineSpatialDistancesInEachCluster <- function(distances, clusters, threshold){
# Add a sub cluster column to the clusters table
clusters$SubSpatialCluster <- NA
# Examine each cluster
for(cluster in unique(clusters$Cluster)){
# Get the isolate IDs for the current cluster
isolates <- clusters[clusters$Cluster == cluster, "SequenceID"]
# Get a spatial distance matrix for the current cluster
matrix <- getSpatialDistancesForCluster(isolates, distances)
# Identify any sub-clusters based upon spatial distances
subClusters <- getClustersFromMatrixWithThreshold(matrix, threshold)
# Assign the subclusters
for(row in seq_len(nrow(subClusters))){
clusters$SubSpatialCluster[which(clusters$SequenceID == subClusters[row, "SequenceID"])] <- subClusters[row, "Cluster"]
}
}
return(clusters)
}
# Set the SNP distance to define cluster
snpThreshold <- 3
# Define genetic distance clusters based on threshold
geneticClusters <- getClustersFromMatrixWithThreshold(geneticDistances, snpThreshold=3)
# Define sub-clusters in the genetic clusters based on spatial distances
clusters <- examineSpatialDistancesInEachCluster(spatialDistances, geneticClusters, threshold=2500)
# Define genetic distance clusters based on threshold
geneticClusters <- getClustersFromMatrixWithThreshold(geneticDistances, threshold=3)
# Define sub-clusters in the genetic clusters based on spatial distances
clusters <- examineSpatialDistancesInEachCluster(spatialDistances, geneticClusters, threshold=2500)
geneticDistances["31-1295", ]
geneticClusters <- getClustersFromMatrixWithThreshold(geneticDistances, threshold=2)
# Define sub-clusters in the genetic clusters based on spatial distances
clusters <- examineSpatialDistancesInEachCluster(spatialDistances, geneticClusters, threshold=2500)
clusters
# Define genetic distance clusters based on threshold
geneticClusters <- getClustersFromMatrixWithThreshold(geneticDistances, threshold=2)
# Define sub-clusters in the genetic clusters based on spatial distances
clusters <- examineSpatialDistancesInEachCluster(spatialDistances, geneticClusters, threshold=2000)
clusters
nSequences <- 50
nSites <- 100
alignment <- matrix(sample(c("A", "C", "G", "T"), nSequences*nSites, replace=TRUE),
nrow=nSequences, ncol=nSites)
rownames(alignment) <- paste("Seq-", 1:nSequences)
plotFASTA <- function(nucleotideAlignment, pdfFileName=NULL, pdfWidth=14, pdfHeight=7, labelSpace=1,
lineForSequenceNames=0, sequenceLabelCex=0.5, xLabCex=1, xTicksCex=1,
legendCex=1, showNucleotide=FALSE){
# Convert the nucleotides to upper case
nucleotideAlignment <- toupper(nucleotideAlignment)
# Check if the input aligment is in the right format
if(class(nucleotideAlignment) == "DNAbin"){
nucleotideAlignment <- as.character(nucleotideAlignment)
}else if(class(nucleotideAlignment) == "alignment" || class(nucleotideAlignment) == "phyDat"){
nucleotideAlignment <- as.character(as.DNAbin(nucleotideAlignment))
}else if(class(nucleotideAlignment) != "matrix"){
stop("Class of input nucleotide alignment not recognised:", class(nucleotideAlignment),
"please provide alignment as a character matrix or in a \"alignment\", \"phyDat\", or \"DNAbin\" format.")
}
# Open a pdf if requested
if(is.null(pdfFileName) == FALSE){
pdf(pdfFileName, width=pdfWidth, height=pdfHeight)
}
# Get and set the plotting margins
currentMar <- par()$mar
par(mar=c(4.1, 5*labelSpace, 3.1, 0.5))
# Note the colour of each nucleotide
nucleotideColours <- list('A'="green", 'C'="blue", 'G'="black", 'T'="red", 'N'="white")
# Note the number of sequences and sites
nSequences <- nrow(nucleotideAlignment)
nSites <- ncol(nucleotideAlignment)
# Create an empty plot
plot(x=NULL, y=NULL, xlim=c(1, nSites), ylim=c(1, nSequences), bty="n", yaxt="n", ylab="", xlab="Position",
cex.lab=xLabCex, cex.axis=xTicksCex)
# Calculate the size of nucleotide to fit within box in matrix
defaultNucleotideWidth <- strwidth("A")
# Examine each sequence
for(sequenceIndex in seq_len(nSequences)){
# Examine each position in the current sequence
for(siteIndex in seq_len(nSites)){
# Get the nucleotide at the current position
nucleotide <- nucleotideAlignment[sequenceIndex, siteIndex]
# Get the colour for the current nucleotide
nucleotideColour <- nucleotideColours[[nucleotide]]
if(is.null(nucleotideColour)){
warning("Nucleotide not recognised:", nucleotide, "only recognises A, C, G, T, or N",
"(sequence index =", sequenceIndex, ", site index =", siteIndex, ").")
}
# Draw a polygon for the current poisition coloured by nucleotide
polygon(x=c(siteIndex-0.5, siteIndex-0.5, siteIndex+0.5, siteIndex+0.5),
y=c(sequenceIndex-0.5, sequenceIndex+0.5, sequenceIndex+0.5, sequenceIndex-0.5),
border=rgb(0,0,0,0), col=nucleotideColour)
}
# Overlay the nucleotides for the current sequence
if(showNucleotide){
text(x=seq_len(nSites), y=rep(sequenceIndex, nSites),
labels=nucleotideAlignment[sequenceIndex, ],
col="white", cex=0.5)
}
}
# Add the sequence names
axis(side=2, at=seq_len(nSequences), labels=rownames(nucleotideAlignment), tick=FALSE, las=1,
line=-1.5+lineForSequenceNames, cex.axis=sequenceLabelCex)
# Add nucleotide legend
legend(x=nSites/2, y=nSequences + (0.15*nSequences), horiz=TRUE, xpd=TRUE, pch=22, col="grey", bty="n", xjust=0.5,
legend=names(nucleotideColours), pt.bg=unlist(nucleotideColours), pt.cex=1.5*legendCex,
cex=legendCex)
# Reset the plotting margins
par(mar=currentMar)
# Close the PDF if requested
if(is.null(pdfFileName) == FALSE){
dev.off()
}
}
plotFASTA(alignment, xTicksCex = 1.5, xLabCex = 1.5)
plotFASTA(alignment, xTicksCex = 1.5)
plotFASTA(alignment, xTicksCex = 1.5)
plotFASTA(alignment, xTicksCex = 1.5, xLabCex=0.75)
plotFASTA(alignment, xTicksCex = 1.5, xLabCex=1.5, sequenceLabelCex=0.25)
plotFASTA(alignment, xTicksCex = 1.5, xLabCex=1.5, sequenceLabelCex=0.4)
library("devtools")
library("roxygen2")
setwd(packageDirectory)
packageDirectory <- "/home/josephcrispell/Desktop/Research/basicPlotteR/"
setwd(packageDirectory)
document()
